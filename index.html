<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="content-type" content="text/html; charset=windows-1251"/>
    <title>GeoJSON with Voronoi</title>
    <style>
        body {font:18px sans-serif}
        path {cursor:pointer}
    </style>
</head>
<body>
    <div style="position:absolute;top:455px">
      <input type="checkbox" id="voronoi">
      <label for="voronoi" style="position:relative;top:2px;">Voronoi</label>
	<output id="ou"></output>
    </div>

    <script src='us-states.js'></script>
    <script src='d3.v3.min.js'></script>
    <script>

function Rnd(min,max,n) {var R = Math.abs((Math.random()*100000) % 1); return 1*(((max-min)*R + min).toFixed(n))}
function pif_c(a,b) {return Math.sqrt(a*a + b*b)}

for (var num=1; num<2; num++){

var dataset = [], k = 0.05, lim = 12000, X, Y, ok, ar_X = [30,50,30,50], ar_Y = [-120,-120,-75,-75]; //ar_X = [25,48,25,48], ar_Y = [-118,-118,-75,-75];
	for (var j=0; j<lim; j++){
	     X = Rnd(ar_X[0],ar_X[1],2);
	     Y = Rnd(ar_Y[1],ar_Y[2],2); ok = 0;
	     for (var i=0; i<ar_X.length; i++){if (pif_c(ar_X[i]-X, ar_Y[i]-Y) >= k) ok++}
	     if (ok == ar_X.length) {ar_X.push(X); ar_Y.push(Y); dataset.push({"f_scale": "EF"+Rnd(0,1,0), "latitude": X, "longitude": Y})}
	}


        // Define the dimensions of the visualization.
        var margin = {top: 20, right: 20, bottom: 20, left: 20},
            width = 800 - margin.left - margin.right,
            height = 500 - margin.top - margin.bottom;

        // Create the SVG container for the visualization and define its dimensions.
        var svg = d3.select("body").append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom);

        // Within the main SVG container, add a group element (<g>) that can be transformed via
        // a translation to account for the margins.
        // Within that group create another group element that can be used to zoom and pan the map.
        var g = svg.append("g")
            .attr("transform", "translate(" + margin.left + "," + margin.top + ")")
            .append("g");

        // Define a variable that tracks which state is currently zoomed (if any) and a variable that
        // indicates if the Voronoi diagram is visible.
        var active = d3.select(null),
            voronoi = false;

        // Set up an event handler to respond to the
        // Voronoi checkbox.
        d3.select("input[type=checkbox]").on("change", function() {toggle();});

        // Define the properties of the map projection.
        var projection = d3.geo.albers()
            .scale(900)
            .translate([width / 2, height / 2]);

        // Define a function that returns the SVG path based on the projection. This
        // function accepts, as input, a selection with an associated array of longitude and latitude values.
        var path = d3.geo.path()
            .projection(projection);

        // Draw the map within the SVG container. Each state is a separate SVG path.
        g.selectAll("path")
            .data(map.features)
          .enter().append("path")
            .attr("id", function(d) {
                return d.properties.abbreviation;
            })
            .attr("d", path)
            .attr("fill", "Silver")
            .attr("stroke", "White")
            .on("click", clicked);

        // Only consider data points that have latitude and longitude values. While
        // we're checking this condition, coerce the CSV strings into data types that we can work with directly.
        var data = dataset.filter(function(d, i) {

            if (d.latitude && d.longitude) {

                // Convert the strings for latitude and longitude into numbers.
                d.latitude = +d.latitude;
                d.longitude = +d.longitude;

                // Convert the F scale string to a number.
                d.f_scale = +d.f_scale[2];

                // Calculate the position of the point within the projection.
                d.position = projection([
                    d.longitude, d.latitude
                ]);

                return true;
            }
        });

        // Compute the polygons for the Voronoi layout.
        // Before we can use D3's Voronoi functions, we have to filter out any duplicate positions.
        var positions = data.map(function(d) { return d.position;})
            .reduce(function(positions, position) {
                if (!positions.some(function(p) {
                    return position[0] === p[0] && position[1] === p[1];
                })) {
                    positions.push(position);
                }
                return positions;
            }, []);
        var polygons = d3.geom.voronoi(positions);

var POI = "Name"+"\t"+"X"+"\t"+"Y"+"\n", PLG = '';
for (var i=0; i<positions.length; i++){
	POI += i +"\t"+ positions[i][0].toFixed(3) +"\t"+ positions[i][1].toFixed(3) +"\n"
}
for (var i=0; i<polygons.length; i++){
   for (var j=0; j<polygons[i].length; j++){
	PLG += polygons[i][j][0].toFixed(3) +"\t"+ polygons[i][j][1].toFixed(3) +"\n"
   } PLG += "\n"
}
document.getElementById("ou").innerHTML = '<br><br>Всего: '+ positions.length;
//CoorJ(POI);
CoorLine(PLG,'Polygon');
//window.open('','','scrollbars=1,width=885,height=650').document.write(PLG)

        // Now we can add the Voronoi polygons to the graph. Initially they're invisible because the stroke opacity is set to zero.
        g.selectAll(".cell")
            .data(polygons)
          .enter().append("path")
            .attr("class", "cell")
            .attr("d", function(d) { return "M" + d.join("L") + "Z"; })
            .attr("stroke", "Green")
            .attr("stroke-opacity", 0)
            .attr("fill", "none");

        // Draw circles on the map for each data point.
        g.selectAll("circle")
            .data(data)
          .enter().append("circle")
            .attr("cx", function(d) { return d.position[0]; })
            .attr("cy", function(d) { return d.position[1]; })
            .attr("r", function(d)  { return 4 + 2*d.f_scale; })
            .attr("stroke", "Magenta")
            .attr("fill", "Cyan")
            .attr("fill-opacity", "0.8");

        // Event handlers.

        // Click on a state.
        function clicked(d) {

            // If clicked on state is already active, reset the map to its initial condition.
            if (active.node() === this) return reset();

            // Otherwise, remove the highlighting from the currently active state.
            active.attr("fill", "#cccccc");

            // And add highlighting to the newly active state.
            active = d3.select(this)
                .attr("fill", "#F77B15");

            // Calculate the bounds for the map that will contain the newly active state.
            var bounds = path.bounds(d),
                dx = bounds[1][0] - bounds[0][0],
                dy = bounds[1][1] - bounds[0][1],
                x = (bounds[0][0] + bounds[1][0]) / 2,
                y = (bounds[0][1] + bounds[1][1]) / 2,
                scale = .9 / Math.max(dx / width, dy / height),
                translate = [width / 2 - scale * x, height / 2 - scale * y];

            // Transition to the newly active state by translation and scaling.
            g.transition()
                .duration(750)
                .style("stroke-width", 1.5 / scale + "px")
                .attr("transform", "translate(" + translate + ")scale(" + scale + ")");

            // To keep the circles from changing size, also transition their radii.
            g.selectAll("circle")
                .transition()
                .duration(750)
                .attr("r", function(d)  { return (4 + 2*d.f_scale)/scale; });
        };

        // Reset to initial condition.
        function reset() {

            // Remove highlighting from active state and note that no state is now active.
            active.attr("fill", "#cccccc");
            active = d3.select(null);

            // Remove the translation and scale transform with a transition.
            g.transition()
                .duration(750)
                .style("stroke-width", "1px")
                .attr("transform", "");

            // Also keep the circles the same size by transitioning their radii at the same time.
            g.selectAll("circle")
                .transition()
                .duration(750)
                .attr("r", function(d)  { return (4 + 2*d.f_scale); });
        };

        // Toggle the visibility of the Voronoi overlay.
        function toggle() {
            g.selectAll(".cell")
                .transition()
                .duration(750)
                .attr("stroke-opacity", voronoi ? 0 : 1);

            voronoi = !voronoi;
        };
}
function isNum(n) {return !isNaN(parseFloat(n)) && isFinite(n)}
function toNum(n) {if (isNum(n)) {n = parseFloat(n.replace(",","."))}; return n}

function CoorJ(J) { var Row, Co, P, X=[], Y=[],
	str = '{"crs":{"type":"name","properties":{"name":"EPSG:3857"}},"type":"FeatureCollection","features":[';
	if (J[0]=='\n') {J = J.slice(1)} // Убирает перенос строки в начале
	Row = J.split("\n"); Co = Row[0].split("\t");
	if (Co.length>500) {alert("Колонок более 500, выполнение прервано"); return false}
	for (var i=1; i<Row.length-1; i++){
		X[i] = toNum(Row[i].split("\t")[Co.length-2]);
		Y[i] = toNum(Row[i].split("\t")[Co.length-1]);
		if (X[i]=='' || Y[i]=='') {continue}
		str +="\n"+'{"type":"Feature","properties":{';
		for (var j=0; j<Co.length-2; j++){
			P = Row[i].split('\t')[j];
			if (isNum(P)) {P = toNum(P)} else {P ='"'+P+'"'} // Преобразование атрибутива в число (для QGIS необязательно, но не лишнее)
			str += '"'+ Row[0].split('\t')[j] +'":'+ P + (j<Co.length-3 ? ',':'') +"\n"
		}
		str +='},"geometry":{"type":"Point","coordinates":['+ X[i].toFixed(3) +','+ Y[i].toFixed(3) +']}}'+ (i<Row.length-2 ? ',':'')
	} str+=']}';
	if (navigator.appVersion.indexOf("Chrome")>-1){
		var lnk = document.createElement("a"); lnk.download ="geo_Points.geojson";
		lnk.href = "data:text/plain;charset=utf-8,"+ str; lnk.click()
	}
}

function CoorLine(s,f) {
	while (s[s.length-1]=="\n") {s = s.slice(0,-1)} // Убирает перенос строки в конце
	while (s.match("\n\n")) {s = s.split("\n\n").join("\n\t\n")}
	var a='', b='', X=[], Y=[], XY=[], n=1, cr, lines = s.split('\n\t\n'),
	str ='{"crs":{"type":"name","properties":{"name":"EPSG:3857"}},"type":"FeatureCollection","features":[';
	for (var i=0; i<lines.length; i++){
		a = "\n"+'{"type":"Feature","properties":{"R":"'+ Rnd(5,500,2) +'"},"geometry":{"type":"'+ f +'","coordinates":['+"\n"; b='';
		for (var j=0; j<lines[i].split("\n").length; j++){ if (a=='') {continue}
			a += ((f=='Polygon' && j==0)?'[':'');
			if (j==lines[i].split("\n").length) {k=j; j=0}
			cr = (lines[i].split("\n")[j]).split('\t');
			X[j] = toNum(cr[cr.length-2]); Y[j] = toNum(cr[cr.length-1]);
			if (X[j]=='' || Y[j]=='' || X[j]<150 || Y[j]<50 || X[j]>600 || Y[j]>330) {a=''; b=''; continue}
			a += '['+ (X[j]*50-15000).toFixed(2) +','+ (Y[j]*50-8500).toFixed(2) +']'+ (j<lines[i].split('\n').length-1 ? ",\n":",\n["+ (X[0]*50-15000).toFixed(2) +','+ (Y[0]*50-8500).toFixed(2) +']]');
			if(j==0) {b += '<tr><td>'+ n +'</td><td>'+ Rnd(5,95,0) +'</td><td><br>'}
			b += (X[j]*50-15000).toFixed(2) +' ; '+ (Y[j]*50-8500).toFixed(2) + (j<lines[i].split('\n').length-1 ? '<br>':'<br><br></td></tr>');
		} if(a) {str+= a +']}}'+ (i<lines.length-1 ? ',':''); XY.push(b); n++}
	} str+=']}';
	if (navigator.appVersion.indexOf("Chrome")>-1){
	//	var lnk = document.createElement("a"); lnk.download = "geo_Polygons "+ num +".geojson"; lnk.href = "data:text/plain;charset=utf-8,"+ str; lnk.click();
		var lns = document.createElement("a"); lns.download = "geo_Polygons "+ num +".html"; lns.href = "data:text/plain;charset=utf-8,"+
	"<meta http-equiv='content-type' content='text/html; charset=utf-8'/>"+
	"<style>th{padding:5pt} td{text-align:center; vertical-align:middle}</style>"+
	"<body onkeydown='if (event.keyCode==27) window.close()' style='font:12pt Consolas'>"+
	' Задание на лабораторную работу № 3 (текущий вариант задания предназначен для студента под номером '+ num +' в списке состава группы ФЭБЗ по журналу):'+
	'<p>1) Нанести площадные объекты ('+ (n-1) +') по данным, представленным в таблице ниже, на слой ГИС по координатам вершин поворотных точек границы (ГСК). Сохранить результат в составе слоя "file P" формата shapefile;</p>'+
	'<p>2) Установить стиль нанесённых объектов (граница: 0.3 мм, HTML код цвета заливки: "#4fc71f", HTML код цвета границы: "#0e150c");</p>'+
	'<p>3) Вычислить площадь нанесённых объектов в формате "0.0 м&#178;" и поместить её в созданную для этого третью колонку;</p>'+
	'<p>4) Вычислить средние координаты нанесённых объектов (X и Y, м) в формате "0.000" и поместить их в созданные для этого колонки 4 и 5;</p>'+
	'<p>5) Создать точечные объекты по вычисленным средним координам на отдельном слое "file PM" (маркер свободный);</p>'+
	'<p>6) Создать выборку объектов слоя "file P" по наличию цифры "'+ Rnd(0,9,0) +'" как последнего символа в составе номера объекта. Сохранить результат в составе слоя "file PS" формата shapefile;</p>'+
	'<p>7) Создать выборку объектов слоя "file P" по номеру объекта, кратного "'+ Rnd(3,8,0) +'". Сохранить результат в составе слоя "file PSM" формата shapefile;</p>'+
	'<p>8) Составить отчёт (на 7-8 страниц, шрифт: 14pt TNR) в формате А5 (печать книжкой) о выполненной работе с описанием задания, процесса выполнения и результатов (сопуствующие иллюстрации обязательны). Отчёт в формате *.doc и созданные слои следует поместить в zip-архив (с номером варианта в качестве его имени), сдать на проверку и подготовиться к защите работы.</p>'+
	"<table border=1 cellpadding=3 style='border:1px solid Grey; border-collapse:collapse; margin:5pt'><tr><th>Номер<br>объекта</th><th>Параметр</th><th>Координаты вершин в ГСК<br>(Восток ; Север)</th></tr>"+ XY.join('') +"</table>Таблица окончена</body>"; lns.click()
	}
}

    </script>
</body>
</html>
